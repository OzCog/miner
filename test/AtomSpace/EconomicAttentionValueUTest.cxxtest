/*******************************************************\
	Filename:	EconomicAttentionValueUTest.cxxtest
	Author:		Joel Pitt
	Copyright:	Singularity Institute for Artificial Intelligence
	Date:		
	Desc:		Unit test for AttentionValue class
\*******************************************************/

#include "EconomicAttentionValue.h"

#define NUM_AVS 4
#define AV1_STI 0
#define AV2_STI 500
#define AV3_STI 20000
#define AV1_LTI 0
#define AV2_LTI 700
#define AV3_LTI 33333
#define AV1_VLTI 0
#define AV2_VLTI 0
#define AV3_VLTI 1
#define AV_LBOUND -32768
#define AV_UBOUND 32767

#define NO_STIM 0
#define LARGE_STIM 30000
#define MAX_STIM 65534
#define MIN_STIM 0

#define DEFAULTATOMSTI 500;
#define DEFAULTATOMLTI 0;
#define DEFAULTATOMVLTI 0;

class EconomicAttentionValueUTest :  public CxxTest::TestSuite {
private:
	
    EconomicAttentionValue::sti_t sti[NUM_AVS];
    EconomicAttentionValue::lti_t lti[NUM_AVS];
    EconomicAttentionValue::vlti_t vlti[NUM_AVS];
    EconomicAttentionValue::stim_t stim[NUM_AVS];

    EconomicAttentionValue* avs[NUM_AVS];    

public:
    EconomicAttentionValueUTest(){
	        
	sti[0] = DEFAULTATOMSTI;
	sti[1] = AV1_STI;
	sti[2] = AV2_STI;
	sti[3] = AV3_STI;

	lti[0] = DEFAULTATOMLTI;
	lti[1] = DEFAULTATOMLTI;
	lti[2] = AV2_LTI;
	lti[3] = AV3_LTI;

	vlti[0] = DEFAULTATOMVLTI;
	vlti[1] = DEFAULTATOMVLTI;
	vlti[2] = DEFAULTATOMVLTI
	vlti[3] = AV3_VLTI;

    EconomicAttentionValue *av = EconomicAttentionValue::factory();
	delete av;
    }

    void setUp() {
	avs[0] = EconomicAttentionValue::factory();
	avs[1] = EconomicAttentionValue::factory(sti[1]);
	avs[2] = EconomicAttentionValue::factory(sti[2], lti[2]);
	avs[3] = EconomicAttentionValue::factory(sti[3], lti[3], vlti[3]);
    }

    void tearDown(){
        for (int i = 0; i < NUM_AVS; i++) {
            delete avs[i];
        }
    }

    void testConstructors(){
        
        EconomicAttentionValue *av;
        
	for(int i = 0; i < NUM_AVS; i++) {
            av = avs[i];
	    //printf("getSTI()=%d, sti[i]=%d\n", av->getSTI(), sti[i]);
	    //printf("getLTI()=%d, lti[i]=%d\n", av->getLTI(), lti[i]);
	    //printf("getVLTI()=%d, vlti[i]=%d\n", av->getVLTI(), vlti[i]);
            TS_ASSERT(av != NULL);
            TS_ASSERT(av->getSTI() == sti[i]);
            TS_ASSERT(av->getLTI() == lti[i]);
            TS_ASSERT(av->getVLTI() == vlti[i]);           
        }
    }

    void testGets() {

        EconomicAttentionValue *av;

	for(int i = 0; i < NUM_AVS; i++) {
            av = avs[i];

            TS_ASSERT(av->getSTI() == sti[i]);
            TS_ASSERT(av->getLTI() == lti[i]);
            TS_ASSERT(av->getVLTI() == vlti[i]);           
        }
    }

    void testclone() {
	EconomicAttentionValue *clonedAV, *av;

	for(int i = 0; i < NUM_AVS; i++) {
            av = avs[i];
	    clonedAV = av->clone();	    
            TS_ASSERT(av->getSTI() == clonedAV->getSTI());
            TS_ASSERT(av->getLTI() == clonedAV->getLTI());
            TS_ASSERT(av->getVLTI() == clonedAV->getVLTI());           
	    TS_ASSERT(av->getStimulus() == clonedAV->getStimulus());
        }
    }

    void testOperatorEquals() {
	

	for(int i = 0; i < NUM_AVS; i++) {
	    const EconomicAttentionValue& av1 = *avs[i];
	    const EconomicAttentionValue& av2 = *av1.clone();
	    //printf("getSTI()=%d, cloned=%d\n", av1.getSTI(), av2.getSTI());
	    //printf("getLTI()=%d, cloned=%d\n", av1.getLTI(), av2.getLTI());
	    //printf("getVLTI()=%d, cloned=%d\n", av1.getVLTI(), av2.getVLTI());	    
            TS_ASSERT(av1 == av2);
        }
    }

    void testgetDefault() {
	const EconomicAttentionValue& av = EconomicAttentionValue::getDefaultAV();

	TS_ASSERT(av.getSTI() == sti[0]);
        TS_ASSERT(av.getLTI() == lti[0]);
        TS_ASSERT(av.getVLTI() == vlti[0]); 
	TS_ASSERT(av.getStimulus() == NO_STIM);
    }

    void testfactory() {
	EconomicAttentionValue *av;
        
	av = EconomicAttentionValue::factory();
	TS_ASSERT(av->getSTI() == sti[0]);
	TS_ASSERT(av->getLTI() == lti[0]);
	TS_ASSERT(av->getVLTI() == vlti[0]);
	delete (av);

	av = EconomicAttentionValue::factory(sti[1]);
	TS_ASSERT(av->getSTI() == sti[1]);
	TS_ASSERT(av->getLTI() == lti[1]);
	TS_ASSERT(av->getVLTI() == vlti[1]);
	delete (av);

	av = EconomicAttentionValue::factory(sti[2], lti[2]);
	TS_ASSERT(av->getSTI() == sti[2]);
	TS_ASSERT(av->getLTI() == lti[2]);
	TS_ASSERT(av->getVLTI() == vlti[2]);
	delete (av);

	av = EconomicAttentionValue::factory(sti[3], lti[3], vlti[3]);
	TS_ASSERT(av->getSTI() == sti[3]);
	TS_ASSERT(av->getLTI() == lti[3]);
	TS_ASSERT(av->getVLTI() == vlti[3]);
	delete (av);
    }

    void testStimulate() {
	
	EconomicAttentionValue *av;
	EconomicAttentionValue::stim_t stim_value = 0;
	EconomicAttentionValue::stim_t new_stim_value = 0;
	
	av = avs[1];
	stim_value = av->getStimulus();
	new_stim_value = av->stimulate(NO_STIM);
	TS_ASSERT_EQUALS(stim_value, new_stim_value);
	stim_value = new_stim_value;

	new_stim_value = av->stimulate(LARGE_STIM);
	TS_ASSERT_EQUALS(new_stim_value, stim_value + LARGE_STIM);
	stim_value = new_stim_value;

	av->resetStimulus();
	TS_ASSERT_EQUALS(av->getStimulus(), 0);
	
    }

    //static std::string toStr();
    void testtoString() {
	char buffer[100];
        //printf("AttentionValue::testtoString()\n");
	for(int i = 0; i < NUM_AVS; i++) {        
	    //printf("AV[%d] = %s\n", i, avs[i]->toString().c_str());
            std::string str = avs[i]->toString();
	    sprintf(buffer, "[%d, %d, %s]", avs[i]->getSTI(), avs[i]->getLTI(), avs[i]->getVLTI() ? "NONDISPOSABLE" : "DISPOSABLE");
            TS_ASSERT(!strcmp(str.c_str(), buffer));
        }
    }  
};
