/*
 * tests/server/PatternUTest.cxxtest
 *
 * Copyright (C) 2009 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/atomspace/Link.h>
#include <opencog/atomspace/Node.h>
#include <opencog/query/DefaultPatternMatchCB.h>
#include <opencog/query/PatternMatch.h>
#include <opencog/server/CogServer.h>
#include <opencog/util/Logger.h>

using namespace opencog;

class PatternUTest :  public CxxTest::TestSuite
{
	private:
		PatternMatchEngine pme;
		PatternMatch pm;
		AtomSpace *as;

		// These handles are documented below.
		Handle hconst;
		Handle hsoln_a;
		Handle hsoln_b;
		Handle hsoln_c;

		Handle hpred_a;
		Handle hpred_b;
		Handle hpred_c;

		Handle hitem_1;
		Handle hitem_2;
		Handle hitem_3;
		Handle hlist;
		Handle hprnode;
		Handle hoc;

		Handle hshort_list;
		Handle hshort_prnode;
		Handle hshort_oc;

		Handle heval;
		Handle hshort_eval;

	public:

		PatternUTest(void)
		{
			logger().setLevel(Logger::DEBUG);
			logger().setPrintToStdoutFlag(true);
		}

		~PatternUTest()
		{
			// erase the log file if no assertions failed
			if (!CxxTest::TestTracker::tracker().suiteFailed())
				std::remove(logger().getFilename().c_str());
		}

		void setUp(void);

		void tearDown(void) { }

		void test_simple_link(void);
		void test_two_links(void);
		void test_eval(void);
		void test_implication(void);
};

class PMCB : public DefaultPatternMatchCB
{
	public:
		PMCB(void);
		virtual bool node_match(Node *, Node *);
		virtual bool solution(std::map<Handle, Handle> &pred_soln,
                            std::map<Handle, Handle> &var_soln);

		int found;
		std::map<Handle, Handle> preds;
		std::map<Handle, Handle> vars;
};

PMCB::PMCB(void)
{
	found = 0;
}

bool PMCB::node_match(Node *npat, Node *nsoln)
{
	Type pattype = npat->getType();
	Type soltype = nsoln->getType();

	// Reject obvioius misatches
	if (pattype != soltype) return true;

	Handle ha = TLB::getHandle(npat);
	Handle hb = TLB::getHandle(nsoln);
	logger().debug("Compare (%lu) %s ==== (%lu) %s", 
		ha.value(), npat->getName().c_str(),
		hb.value(), nsoln->getName().c_str());

	if (npat == nsoln) return false;
	return true;
}

bool PMCB::solution(std::map<Handle, Handle> &pred_soln,
                    std::map<Handle, Handle> &var_soln)
{
	found ++;
	preds = pred_soln;
	vars = var_soln;
	return false;
}

/*
 * This function sets up the following structures:
 *
 *    ConceptNode "some const concept node"         ;; hconst
 *    ConceptNode "desired solution concept node a" ;; hsoln_a
 *    ConceptNode "desired solution concept node b" ;; hsoln_b
 *    ConceptNode "desired solution concept node c" ;; hsoln_c
 *    ConceptNode "incorrect solution concept node"
 *
 *    InheritanceLink   ;; hpred_a
 *       ConceptNode "some const concept node"
 *       ConceptNode "desired solution concept node a"
 *
 *    ListLink     ;; hpred_b
 *       ConceptNode "some const concept node"
 *       ConceptNode "desired solution concept node b"
 *
 *    ListLink     ;; hpred_c
 *       ConceptNode "some const concept node"
 *       ConceptNode "desired solution concept node c"
 *
 *    AssociativeLink 
 *       ConceptNode "some const concept node"
 *       ConceptNode "incorrect solution concept node"
 *
 *    EvaluationLink                                ;; hoc
 *       PredicateNode "relationship blaupunkt"     ;; hprnode
 *       ListLink                                   ;; hlist
 *          ConceptNode "concept kanjiru 1"         ;; hitem_1
 *          ConceptNode "concept kangaeru 2"        ;; hitem_2
 *          ConceptNode "concept nihongo 3"         ;; hitem_3
 *
 *    EvaluationLink                                ;; hshort_oc
 *       PredicateNode "relationship weltanshaung"  ;; hshort_prnode
 *       ListLink                                   ;; hshort_list
 *          ConceptNode "concept kanjiru 1"         ;; hitem_1
 *          ConceptNode "concept kangaeru 2"        ;; hitem_2
 */
void PatternUTest::setUp(void)
{
	CogServer& cogserver = static_cast<CogServer&>(server());
	as = cogserver.getAtomSpace();
	pm.set_atomspace(as);
	pme.set_atomspace(as);

	// create a gnarly graph
	Node ncon(CONCEPT_NODE, "some const concept node");
	hconst = as->addRealAtom(ncon);

	Node na(CONCEPT_NODE, "desired solution concept node a");
	hsoln_a = as->addRealAtom(na);

	Node nb(CONCEPT_NODE, "desired solution concept node b");
	hsoln_b = as->addRealAtom(nb);

	Node nc(CONCEPT_NODE, "desired solution concept node c");
	hsoln_c = as->addRealAtom(nc);

	Link la(INHERITANCE_LINK, hconst, hsoln_a);
	hpred_a = as->addRealAtom(la);

	Link lb(LIST_LINK, hconst, hsoln_b);
	hpred_b = as->addRealAtom(lb);

	Link lc(LIST_LINK, hconst, hsoln_c);
	hpred_c = as->addRealAtom(lc);

	// create a confounding link, like above, but different
	Node nbw(CONCEPT_NODE, "incorrect solution concept node");
	Handle hwrong = as->addRealAtom(nbw);

	Link ldw(ASSOCIATIVE_LINK, hconst, hwrong);
	as->addRealAtom(ldw);

	// Create a standard-format opencog predicate
	Node n1(CONCEPT_NODE, "concept kanjiru 1");
	hitem_1 = as->addRealAtom(n1);
	Node n2(CONCEPT_NODE, "concept kangaeru 2");
	hitem_2 = as->addRealAtom(n2);
	Node n3(CONCEPT_NODE, "concept nihongo 3");
	hitem_3 = as->addRealAtom(n3);

	Link pl(LIST_LINK, hitem_1, hitem_2, hitem_3);
	hlist = as->addRealAtom(pl);

	Node pr(PREDICATE_NODE, "relationship blaupunkt");
	hprnode = as->addRealAtom(pr);

	Link pe(EVALUATION_LINK, hprnode, hlist);
	hoc = as->addRealAtom(pe);

	// Same as above, but with only two items in the list.
	Link pls(LIST_LINK, hitem_1, hitem_2);
	hshort_list = as->addRealAtom(pls);

	Node prs(PREDICATE_NODE, "relationship weltanshaung");
	hshort_prnode = as->addRealAtom(prs);

	Link pes(EVALUATION_LINK, hshort_prnode, hshort_list);
	hshort_oc = as->addRealAtom(pes);
}

void PatternUTest::test_simple_link(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	// Define the pattern to match against.
	Node nvar(VARIABLE_NODE, "variable node");
	Handle hvar = as->addRealAtom(nvar);

	Link le(INHERITANCE_LINK, hconst, hvar);
	Handle he = as->addRealAtom(le);

	std::vector<Handle> vars;
	vars.push_back(hvar);

	std::vector<Handle> preds;
	preds.push_back(he);

	PMCB pmcb;
	pme.match(&pmcb, preds, vars);

	// Should find only one solution.
	TSM_ASSERT_EQUALS("wrong number of solutions", pmcb.found, 1);
	TSM_ASSERT("incorrect solution", hsoln_a == pmcb.vars[hvar]);
	TSM_ASSERT("incorrect predicate", hpred_a == pmcb.preds[he]);

	// Remove garbage, just in case ... 
	as->removeAtom(he);
	as->removeAtom(hvar);
	logger().debug("END TEST: %s", __FUNCTION__);
}

/*
 * This test creates the following pattern, for matching:
 *
 *    AndList
 *       ListLink
 *          ConceptNode "some const concept node"
 *          VariableNode "variable node x"
 *       ListLink
 *          ConceptNode "some const concept node"
 *          VariableNode "variable node y"
 *
 *    ListLink
 *       VariableNode "variable node x"
 *       VariableNode "variable node y"
 *
 * This is used to try to match hypergraphs in the atomspace, defined
 * above. Four answers are expected, since "desired solution concept
 * node b" and "c" can be paired to "x", "y" four different ways.
 */
void PatternUTest::test_two_links(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	// Define the pattern to match against.
	Node nx(VARIABLE_NODE, "variable node x");
	Handle hx = as->addRealAtom(nx);

	Node ny(VARIABLE_NODE, "variable node y");
	Handle hy = as->addRealAtom(ny);

	Link lx(LIST_LINK, hconst, hx);
	Handle hlx = as->addRealAtom(lx);

	Link ly(LIST_LINK, hconst, hy);
	Handle hly = as->addRealAtom(ly);

	Link an(AND_LINK, hlx, hly);
	Handle han = as->addRealAtom(an);

	Link lv(LIST_LINK, hx, hy);
	Handle hv = as->addRealAtom(lv);

	std::vector<Handle> vars;
	vars.push_back(hx);
	vars.push_back(hy);

	std::vector<Handle> preds;
	preds.push_back(hlx);
	preds.push_back(hly);

	PMCB pmcb;
	pme.match(&pmcb, preds, vars);

	// Should find four solutions:
	// var_x = soln_b and var_y = soln_b
	// var_x = soln_b and var_y = soln_c
	// var_x = soln_c and var_y = soln_b
	// var_x = soln_c and var_y = soln_c
	TSM_ASSERT_EQUALS("wrong number of solutions", pmcb.found, 4);
	// TSM_ASSERT("incorrect solution", hsoln_b == pmcb.vars[hx]);
	// TSM_ASSERT("incorrect predicate", hpred_b == pmcb.preds[hlx]);

	// Test the non-std::vector interface also.
	pmcb.found = 0;
	pm.match(&pmcb, han, hv);
	TSM_ASSERT_EQUALS("wrong number of solutions", pmcb.found, 4);

	logger().debug("END TEST: %s", __FUNCTION__);
}

/*
 * This test case creates the following pattern-matching and variable
 * structures:
 *
 *    EvaluationLink                                ;; heval
 *       VariableNode "3-tuple relationship variable"
 *       ListLink
 *          ConceptNode "concept kanjiru 1"         ;; hitem_1
 *          VariableNode "concept variable"
 *          ConceptNode "concept nihongo 3"         ;; hitem_3
 *
 *    EvaluationLink                                ;; hshort_eval
 *       VariableNode "2-tuple relationship variable"
 *       ListLink
 *          ConceptNode "concept kanjiru 1"         ;; hitem_1
 *          VariableNode "concept variable"
 *
 */
void PatternUTest::test_eval(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	// Create a standard-format opencog predicate
	Node n1(CONCEPT_NODE, "concept kanjiru 1");
	Handle h1 = as->addRealAtom(n1);
	Node n2(VARIABLE_NODE, "concept variable");
	Handle h2 = as->addRealAtom(n2);
	Node n3(CONCEPT_NODE, "concept nihongo 3");
	Handle h3 = as->addRealAtom(n3);

	Link pl(LIST_LINK, h1, h2, h3);
	Handle hl = as->addRealAtom(pl);

	Node pr(VARIABLE_NODE, "3-tuple relationship variable");
	Handle hprn = as->addRealAtom(pr);

	Link pe(EVALUATION_LINK, hprn, hl);
	heval = as->addRealAtom(pe);

	std::vector<Handle> vars;
	vars.push_back(hprn);
	vars.push_back(h2);

	std::vector<Handle> preds;
	preds.push_back(heval);

	PMCB pmcb;
	pme.match(&pmcb, preds, vars);

	// Should find one solution
	TSM_ASSERT_EQUALS("wrong number of solutions", pmcb.found, 1);
	TSM_ASSERT("incorrect solution", hitem_2 == pmcb.vars[h2]);
	TSM_ASSERT("incorrect pr-node", hprnode == pmcb.vars[hprn]);
	TSM_ASSERT("incorrect predicate", hoc == pmcb.preds[heval]);

	// Do it again, but with a truncated list 
	Link pls(LIST_LINK, h1, h2);
	Handle hls = as->addRealAtom(pls);

	Node prs(VARIABLE_NODE, "2-tuple relationship variable");
	Handle hprns = as->addRealAtom(prs);

	Link pes(EVALUATION_LINK, hprns, hls);
	hshort_eval = as->addRealAtom(pes);

	std::vector<Handle> svars;
	svars.push_back(hprns);
	svars.push_back(h2);

	std::vector<Handle> spreds;
	spreds.push_back(hshort_eval);

	pmcb.found = 0; // reset the counter !!
	pme.match(&pmcb, spreds, svars);

	// Should find one solution
	TSM_ASSERT_EQUALS("wrong number of solutions", pmcb.found, 1);
	TSM_ASSERT("incorrect solution", hitem_2 == pmcb.vars[h2]);
	TSM_ASSERT("incorrect pr-node", hshort_prnode == pmcb.vars[hprns]);
	TSM_ASSERT("incorrect predicate", hshort_oc == pmcb.preds[hshort_eval]);

	// And do it again, now matching two clauses
	preds.push_back(hshort_eval);
	vars.push_back(hprns);
	pmcb.found = 0; // reset the counter !!
	pme.match(&pmcb, preds, vars);
	TSM_ASSERT_EQUALS("wrong number of solutions", pmcb.found, 1);
	TSM_ASSERT("incorrect solution", hitem_2 == pmcb.vars[h2]);
	TSM_ASSERT("incorrect pr-node", hprnode == pmcb.vars[hprn]);
	TSM_ASSERT("incorrect pr-node", hshort_prnode == pmcb.vars[hprns]);
	TSM_ASSERT("incorrect predicate", hoc == pmcb.preds[heval]);
	TSM_ASSERT("incorrect predicate", hshort_oc == pmcb.preds[hshort_eval]);

	logger().debug("END TEST: %s", __FUNCTION__);
}

/*
 * This creates the following implication structure
 *
 *    ImplicationLink
 *       AndLink
 *           EvaluationLink  ;; heval, as given above ... 
 *           EvaluationLink  ;; hshorteval, as given above ... 
 *       ParseLink
 *           VariableNode "concept variable"
 *
 * After evaluation, it is expected tht the atom-space will
 * contain the following:
 *
 *    ParseLink
 *       ConceptNode "concept kangaeru 2"        ;; hitem_2
 *
 * Since that is what the variable is expected to bind to.
 */
void PatternUTest::test_implication(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	Link an(AND_LINK, heval, hshort_eval);
	Handle han = as->addRealAtom(an);

	Node n2(VARIABLE_NODE, "concept variable");
	Handle h2 = as->addRealAtom(n2);

	Link pa(PARSE_LINK, h2);
	Handle hpa = as->addRealAtom(pa);

	Link im(IMPLICATION_LINK, han, hpa);
	Handle him = as->addRealAtom(im);

	pm.imply(him);

	// Remove the parse link, so that the other one is easier to find.
	as->removeAtom(him);
	as->removeAtom(hpa);

	// At this point, the AtomSpace should contain a structure
	// that looks like the below. Look for it.
	//
	//   ParseLink
	//      ConceptNode "concept kangaeru 2"        ;; hitem_2
	//
	// Be sure to expl;icitly check that we got hitem_2 as the result

	std::vector<Handle> ret;
	as->getHandleSet(back_inserter(ret), PARSE_LINK);

	TSM_ASSERT_EQUALS("incorrect implication", ret.size(), 1);
	if (0 < ret.size())
	{
		Atom *apl = TLB::getAtom(ret[0]);
		Link *lpl = dynamic_cast<Link *>(apl);
		TSM_ASSERT("null pointer", NULL != lpl);

		Handle solution = lpl->getOutgoingSet()[0];
		TSM_ASSERT("incorrect solution", hitem_2 == solution);
	}

	logger().debug("END TEST: %s", __FUNCTION__);
}
