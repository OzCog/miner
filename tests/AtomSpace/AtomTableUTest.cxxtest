/*
 * tests/AtomSpace/AtomTableUTest.cxxtest
 *
 * Copyright (C) 2002-2007 Novamente LLC
 * Copyright (C) 2008 by Singularity Institute for Artificial Intelligence
 * All Rights Reserved
 *
 * Written by Welter Silva <welter@vettalabs.com>
 *            Gustavo Gama <gama@vettalabs.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "AtomSpace.h"
#include "AtomTable.h"
#include "Node.h"
#include "FileXMLBufferReader.h"
#include "HandleEntry.h"
#include "TLB.h"
#include "NMXmlParser.h"
#include "SimpleTruthValue.h"
#include "CompositeTruthValue.h"
#include "AtomSpaceDefinitions.h"
#include "ClassServer.h"
#include "Link.h"
#include "Logger.h"
#include "Config.h"

#include <iostream>
#include <fstream>

const char* gpnNames[] = {"GPN1", "GPN2", "GPN3", "GPN4", "GNP5", "GNP6"};
int numberOfExpectedMatches[] = {26, 26, 26, 1, 1, 1};

#define VH1 VersionHandle(HYPOTHETICAL,  (Handle) 1)
#define VH2 VersionHandle(CONTEXTUAL,  (Handle) 2)

int numberOfExpectedMatchesWithVH1[] = {15, 15, 15, 0, 0, 0};
int numberOfExpectedMatchesWithVH2[] = {15, 15, 15, 1, 1, 1};

class AtomTableUTest : public CxxTest::TestSuite
{

private:

    AtomTable* table;
    AtomSpace* atomSpace;

public:

    AtomTableUTest() {}
    ~AtomTableUTest() {}

    void setUp() {
        /* load xml files with all necessary nodes and links  */
        std::vector<XMLBufferReader*> readers(1, new FileXMLBufferReader(ATOM_TABLE_TEST_XML_FILE));
        atomSpace = new AtomSpace();
        // Check for existing links because there are 2 identical links in the test xml file
        HandleEntry* result = NMXmlParser::loadXML(readers, atomSpace, false);
        delete result;
        table = (AtomTable*) & (atomSpace->getAtomTable());
        delete readers[0];
    }

    void tearDown() {
        delete atomSpace;
    }

    void REMOVEDtestSimple() {
        AtomTable atomTable(false);
        Handle word = atomTable.add(new Node(WORD_NODE, "test"));
        Handle sense = atomTable.add(new Node(WORD_SENSE_NODE, "28675194"));
        std::vector<Handle> os;
        os.push_back(word);
        os.push_back(sense);
        atomTable.add(new Link(INHERITANCE_LINK, os));
    }

    void REMOVEDtestPredicateIndices() {
        /* TODO: REVIEW ALL THIS STUFF */
        HandleEntry* expectedEntries[6];
        //printf("building expectedEntries\n");
        for (int index = 0; index < 6; index++) {
            HandleEntry* indexedHandles = table->makeSet(NULL, table->getPredicateIndexHead(index), PREDICATE_INDEX | index);
            //printf("indexedHandles for index = %d => %p\n", index, indexedHandles);
            expectedEntries[index] = indexedHandles;
            //printf("Handles in the index %d: \n", index);
            int matchCount = 0;
            while (indexedHandles != NULL) {
                matchCount++;
                //printf("%p (%d)\t", indexedHandles->handle, TLB::getAtom(indexedHandles->handle)->getType());
                indexedHandles = indexedHandles->next;
            }
            //printf("\ncount = %d, expected count = %d\n", matchCount, numberOfExpectedMatches[index]);
            TS_ASSERT(matchCount == numberOfExpectedMatches[index]);
        }
        //printf("testPredicateIndices with NULL_VERSION_HANDLE\n");
        for (int index = 0; index < 6; index++) {
            HandleEntry* indexedHandles = table->findHandlesByGPN(gpnNames[index]);
            //printf("indexedHandles for index = %d => %p\n", index, indexedHandles);
            //printf("Handles that matches predicate %s: \n", gpnNames[index]);
            HandleEntry* expectedEntry = expectedEntries[index];
            while (indexedHandles != NULL) {
                TS_ASSERT(expectedEntry);
                TS_ASSERT(expectedEntry->handle == indexedHandles->handle);
                //printf("%p (%d)\t", indexedHandles->handle, TLB::getAtom(indexedHandles->handle)->getType());
                indexedHandles = indexedHandles->next;
                expectedEntry = expectedEntry->next;
            }
            TS_ASSERT(!expectedEntry);
            //printf("\n");
        }
        // test with non-null VersionHandles
        //printf("adding versioned TVs\n");
        for (int index = 0; index < 6; index++) {
            HandleEntry* expectedEntry = expectedEntries[index];
            int count = 0;
            while (expectedEntry != NULL) {
                if (count < numberOfExpectedMatchesWithVH1[index]) {
                    //printf("adding versioned tv with VH1\n");
                    Atom* atom = TLB::getAtom(expectedEntry->handle);
                    TruthValue* tv = CompositeTruthValue(TruthValue::NULL_TV(), VH1).merge(atom->getTruthValue());
                    atom->setTruthValue(*tv);
                    delete tv;
                    //printf("resulting tv = %s\n", atom->getTruthValue()->toString().c_str());
                }
                if (numberOfExpectedMatches[index] - count <=  numberOfExpectedMatchesWithVH2[index]) {
                    //printf("adding versioned tv with VH2\n");
                    Atom* atom = TLB::getAtom(expectedEntry->handle);
                    TruthValue* tv = CompositeTruthValue(TruthValue::NULL_TV(), VH2).merge(atom->getTruthValue());
                    atom->setTruthValue(*tv);
                    delete tv;
                    //printf("resulting tv = %s\n", atom->getTruthValue()->toString().c_str());
                }
                expectedEntry = expectedEntry->next;
                count++;
            }
        }
        //printf("testPredicateIndices with VH1\n");
        for (int index = 0; index < 6; index++) {
            HandleEntry* indexedHandles = table->findHandlesByGPN(gpnNames[index], VH1);
            //printf("indexedHandles for index = %d => %p\n", index, indexedHandles);
            HandleEntry* expectedEntry = expectedEntries[index];
            int count = 0;
            while (indexedHandles != NULL) {
                TS_ASSERT(expectedEntry);
                TS_ASSERT(expectedEntry->handle == indexedHandles->handle);
                //printf("Checking atom with TV = %s\n", TLB::getAtom(indexedHandles->handle)->getTruthValue().toString().c_str());
                TS_ASSERT(TLB::getAtom(indexedHandles->handle)->getTruthValue().getType() == COMPOSITE_TRUTH_VALUE);
                indexedHandles = indexedHandles->next;
                expectedEntry = expectedEntry->next;
                count++;
            }
            //printf("count before = %d\n", count);
            while (count < numberOfExpectedMatches[index]) {
                TS_ASSERT(expectedEntry);
                expectedEntry = expectedEntry->next;
                count++;
            }
            //printf("count after = %d\n", count);
            TS_ASSERT(!expectedEntry);
        }
        //printf("testPredicateIndices with VH2\n");
        for (int index = 0; index < 6; index++) {
            HandleEntry* indexedHandles = table->findHandlesByGPN(gpnNames[index], VH2);
            //printf("indexedHandles for index = %d => %p\n", index, indexedHandles);
            HandleEntry* expectedEntry = expectedEntries[index];
            int count = 0;
            while (numberOfExpectedMatches[index] - count > numberOfExpectedMatchesWithVH2[index]) {
                TS_ASSERT(expectedEntry);
                expectedEntry = expectedEntry->next;
                count++;
            }
            //printf("count before = %d\n", count);
            while (indexedHandles != NULL) {
                TS_ASSERT(expectedEntry);
                TS_ASSERT(expectedEntry->handle == indexedHandles->handle);
                //printf("Checking atom with TV = %s\n", TLB::getAtom(indexedHandles->handle)->getTruthValue()->toString().c_str());
                TS_ASSERT(TLB::getAtom(indexedHandles->handle)->getTruthValue().getType() == COMPOSITE_TRUTH_VALUE);
                indexedHandles = indexedHandles->next;
                expectedEntry = expectedEntry->next;
                count++;
            }
            //printf("count after = %d\n", count);
            TS_ASSERT(!expectedEntry);
        }

        //printf("testPredicateIndices(): END TEST\n");fflush(stdout);
    }

    // Look for atoms in the following structure:
    //      <ListLink timestamp="630057840">
    //          <Element class="CWPixelPerceptNode" name="630057840_11"/>
    //          <Element class="NumberNode" name="12"/>
    //      </ListLink>
    void testGetHandleSet() {
        //== getHandleSet(const char**, Type*, bool*, Arity, Type = ATOM, bool = true) ==/
        const char* names1[] = {"630057840_11", "12"};
        Type types1[] = {CW_PIXEL_PERCEPT_NODE, NUMBER_NODE};
        HandleEntry* result = table->getHandleSet(names1, types1, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete (result);

        const char* names2[] = {"12", "630057840_11"};
        Type types2[] = {NUMBER_NODE, CW_PIXEL_PERCEPT_NODE};
        result = table->getHandleSet(names2, types2, NULL, 2, LIST_LINK, false);
        TS_ASSERT(!result);

        const char* names3[] = {NULL, "12"};
        Type types3[] = {NOTYPE, NUMBER_NODE};
        result = table->getHandleSet(names3, types3, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        const char* names4[] = {NULL, "630057840_11"};
        Type types4[] = {NOTYPE, CW_PIXEL_PERCEPT_NODE};
        result = table->getHandleSet(names4, types4, NULL, 2, LIST_LINK, false);
        //if (result != NULL) printf("result = %s\n", result->toString().c_str());
        TS_ASSERT(!result);

        result = table->getHandleSet((const char**) NULL, types1, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        result = table->getHandleSet((const char**) NULL, types2, NULL, 2, LIST_LINK, false);
        //if (result != NULL) printf("result = %s\n", result->toString().c_str());
        TS_ASSERT(!result);

        TS_ASSERT_THROWS(table->getHandleSet(names1, NULL, NULL, 2, LIST_LINK, false), RuntimeException&);
        TS_ASSERT_THROWS(table->getHandleSet(names2, NULL, NULL, 2, LIST_LINK, false), RuntimeException&);
        TS_ASSERT_THROWS(table->getHandleSet(names3, NULL, NULL, 2, LIST_LINK, false), RuntimeException&);
        TS_ASSERT_THROWS(table->getHandleSet(names4, NULL, NULL, 2, LIST_LINK, false), RuntimeException&);

        //== getHandleSet(Handle*, Type*, bool*, Arity, Type = ATOM, bool = true) ==/
        std::vector<Handle> handles1(2);
        handles1[0] = table->getHandle("630057840_11", CW_PIXEL_PERCEPT_NODE);
        handles1[1] = table->getHandle("12", NUMBER_NODE);
        result = table->getHandleSet(handles1, types1, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        std::vector<Handle> handles2(2);
        handles2[0] = table->getHandle("12", NUMBER_NODE);
        handles2[1] = table->getHandle("630057840_11", CW_PIXEL_PERCEPT_NODE);
        result = table->getHandleSet(handles2, types2, NULL, 2, LIST_LINK, false);
        TS_ASSERT(!result);
        //printf("result = %s\n", result->toString().c_str());

        std::vector<Handle> handles3(2);
        handles3[0] = UNDEFINED_HANDLE;
        handles3[1] = table->getHandle("12", NUMBER_NODE);
        result = table->getHandleSet(handles3, types3, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        std::vector<Handle> handles4(2);
        handles4[0] = table->getHandle("12", NUMBER_NODE);
        handles4[1] = UNDEFINED_HANDLE;
        result = table->getHandleSet(handles4, types4, NULL, 2, LIST_LINK, false);
        TS_ASSERT(!result);
        //printf("result = %s\n", result->toString().c_str());

        result = table->getHandleSet(std::vector<Handle>(), types1, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        result = table->getHandleSet(std::vector<Handle>(), types2, NULL, 2, LIST_LINK, false);
        //if (result != NULL) printf("result = %s\n", result->toString().c_str());
        TS_ASSERT(!result);

        result = table->getHandleSet(handles1, NULL , NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        result = table->getHandleSet(handles2, NULL, NULL, 2, LIST_LINK, false);
        //if (result != NULL) printf("result = %s\n", result->toString().c_str());
        TS_ASSERT(!result);

        result = table->getHandleSet(handles3, NULL , NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        result = table->getHandleSet(handles4, NULL, NULL, 2, LIST_LINK, false);
        //if (result != NULL) printf("result = %s\n", result->toString().c_str());
        TS_ASSERT(!result);

        //== getHandleSet(Type*, bool*, Arity, Type = ATOM, bool = true) ==/

        result = table->getHandleSet(types1, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        result = table->getHandleSet(types2, NULL, 2, LIST_LINK, false);
        TS_ASSERT(!result);

        result = table->getHandleSet(types3, NULL, 2, LIST_LINK, false);
        TS_ASSERT(result);
        //printf("result = %s\n", result->toString().c_str());
        delete(result);

        result = table->getHandleSet(types4, NULL, 2, LIST_LINK, false);
        //if (result != NULL) printf("result = %s\n", result->toString().c_str());
        TS_ASSERT(!result);
    }

    void testGetHandleSet_bugfix1() {
        HandleSeq emptyOutgoing;
        HandleEntry* result = table->getHandleSet(emptyOutgoing, NULL, NULL, emptyOutgoing.size(), LIST_LINK, false);
        TS_ASSERT(!result);
        result = table->getHandleSet(emptyOutgoing, NULL, NULL, emptyOutgoing.size(), LIST_LINK, true);
        TS_ASSERT(!result);
        Link* link = new Link(LIST_LINK, emptyOutgoing);
        Handle h = table->add(link);
        if (TLB::getHandle(link) != h) delete link;
        result = table->getHandleSet(emptyOutgoing, NULL, NULL, emptyOutgoing.size(), LIST_LINK, false);
        TS_ASSERT(result);
        delete result;
        result = table->getHandleSet(emptyOutgoing, NULL, NULL, emptyOutgoing.size(), LIST_LINK, true);
        TS_ASSERT(result);
        delete result;
    }

    void testPrint() {
        const char *filename = "AtomTableUText.log";
        std::ofstream out(filename);

        out << "All Atoms:" << endl;
        table->print(out);
        out << "All Nodes:" << endl;
        table->print(out, NODE);
        out << "All ConceptNodes:" << endl;
        table->print(out, CONCEPT_NODE, false);
        out << "All Links:" << endl;
        table->print(out, LINK);
        out << "All ListLinks:" << endl;
        table->print(out, LIST_LINK, false);

        out.close();

        if (!CxxTest::TestTracker::tracker().testFailed())
            std::remove(filename);
    }

    void testImportanceUpdate() {
        AtomTable atomTable;

        /* add a simple set of links & nodes */
        Node* wordNode = new Node(WORD_NODE, "test");
        wordNode->setAttentionValue(*AttentionValue::factory((AttentionValue::sti_t) - 10));
        Handle wnHandle = atomTable.add(wordNode);

        Node* senseNode = new Node(WORD_SENSE_NODE, "28675194");
        senseNode->setAttentionValue(*AttentionValue::factory((AttentionValue::sti_t) 30));
        Handle snHandle = atomTable.add(senseNode);

        std::vector<Handle> os;
        os.push_back(wnHandle);
        os.push_back(snHandle);
        Link* inheritanceLink = new Link(INHERITANCE_LINK, os);
        inheritanceLink->setAttentionValue(*AttentionValue::factory((AttentionValue::sti_t) 500));
        Handle linkHandle = atomTable.add(inheritanceLink);

        // force sti decaying
        for (int i = 0; i < 10; i++)
            atomTable.decayShortTermImportance();

        // test the updated STIs
        TS_ASSERT(TLB::getAtom(wnHandle)->getAttentionValue().getSTI()   == -20);
        TS_ASSERT(TLB::getAtom(snHandle)->getAttentionValue().getSTI()   ==  20);
        TS_ASSERT(TLB::getAtom(linkHandle)->getAttentionValue().getSTI() == 490);
    }

    void testRemovalByDecay() {
        AtomTable atomTable;
        AttentionValue::sti_t min_sti = opencog::config().get_int("MIN_STI");

        /* add a simple tree of links & nodes */
        Node* wordNode = new Node(WORD_NODE, "test");
        wordNode->setAttentionValue(*AttentionValue::factory((AttentionValue::sti_t) (min_sti + 7)));
        Handle wnHandle = atomTable.add(wordNode);

        Node* senseNode = new Node(WORD_SENSE_NODE, "28675194");
        senseNode->setAttentionValue(*AttentionValue::factory((AttentionValue::sti_t) (min_sti + 5)));
        Handle snHandle = atomTable.add(senseNode);

        std::vector<Handle> os;
        os.push_back(wnHandle);
        os.push_back(snHandle);
        Link* inheritanceLink = new Link(INHERITANCE_LINK, os);
        inheritanceLink->setAttentionValue(*AttentionValue::factory((AttentionValue::sti_t) (min_sti + 6)));
        atomTable.add(inheritanceLink);

        Link* listLink = new Link(LIST_LINK, os);
        listLink->setAttentionValue(*AttentionValue::factory((AttentionValue::sti_t) (min_sti + 5)));
        atomTable.add(listLink);

        // decay sti up to the threshold where the least important atoms
        // should be about to be removed
        for (int i = 0; i < 5; i++) atomTable.decayShortTermImportance();
        // and test the existance of each atom
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_NODE)        != NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_SENSE_NODE)  != NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) INHERITANCE_LINK) != NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) LIST_LINK)        != NULL);

        // run another decaying cycle; the list link node should have been
        // removed
        atomTable.decayShortTermImportance();
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_NODE)        != NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_SENSE_NODE)  != NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) INHERITANCE_LINK) != NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) LIST_LINK)        == NULL);

        // an another one; the inheritance link and the sense node should have
        // been removed
        atomTable.decayShortTermImportance();
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_NODE)        != NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_SENSE_NODE)  == NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) INHERITANCE_LINK) == NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) LIST_LINK)        == NULL);

        // and another, final one; by now all nodes should have been removed
        atomTable.decayShortTermImportance();
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_NODE)        == NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) WORD_SENSE_NODE)  == NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) INHERITANCE_LINK) == NULL);
        TS_ASSERT(atomTable.getHandleSet((Type) LIST_LINK)        == NULL);
    }

};
