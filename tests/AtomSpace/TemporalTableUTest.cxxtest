/*
 * tests/AtomSpace/TemporalTableUTest.cxxtest
 *
 * Copyright (C) 2002-2007 Novamente LLC
 * All Rights Reserved
 *
 * Written by Welter Silva <welter@vettalabs.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as 
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses 
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <TemporalTable.h>
#include <Node.h>
#include "CoreUtils.h"
#include "numeric.h"

//=============== Tables used for testing both get and remove methods ================= //
#define NUMBER_OF_HANDLES 2
#define NUMBER_OF_SEARCH_INTERVALS 10
#define NUMBER_OF_CRITERIA 10

    static Temporal search_intervals[NUMBER_OF_SEARCH_INTERVALS] = {
          Temporal(0,0), 
          Temporal(0,1),
          Temporal(1,1), 
          Temporal(1,2),
          Temporal(2,2), 
          Temporal(2,3),
          Temporal(3,3), 
          Temporal(3,4),
          Temporal(4,4), 
          Temporal(4,5)
        };

    static TemporalTable::TemporalRelationship criteria[NUMBER_OF_CRITERIA] = {
            TemporalTable::STARTS_BEFORE,
            TemporalTable::STARTS_WITHIN,
            TemporalTable::STARTS_AFTER,
            TemporalTable::ENDS_BEFORE,
            TemporalTable::ENDS_WITHIN,
            TemporalTable::ENDS_AFTER,
            TemporalTable::NEXT_AFTER_START_OF,
            TemporalTable::NEXT_AFTER_END_OF,
            TemporalTable::PREVIOUS_BEFORE_START_OF,
            TemporalTable::PREVIOUS_BEFORE_END_OF,
        };
        
    /* Map of entries for these tests: 
     *  H0       H1
     * [0,0]    [1,1]
     * [1,2]    [2,3]
     * [0,2]    [1,3]
     */
    static int expectedNumberOfEntries[NUMBER_OF_HANDLES][NUMBER_OF_SEARCH_INTERVALS][NUMBER_OF_CRITERIA] = {
         { {0,2,1,0,1,2,1,1,0,0},{0,3,0,0,1,2,1,0,0,1},{2,1,0,1,0,2,0,0,1,1},{2,1,0,1,2,0,0,0,1,1},{3,0,0,1,2,0,0,0,1,1},
           {3,0,0,1,2,0,0,0,1,1},{3,0,0,3,0,0,0,0,1,1},{3,0,0,3,0,0,0,0,1,1},{3,0,0,3,0,0,0,0,1,1},{3,0,0,3,0,0,0,0,1,1} },
         { {0,0,3,0,0,3,1,1,0,0},{0,2,1,0,1,2,1,1,0,0},{0,2,1,0,1,2,1,1,0,0},{0,3,0,0,1,2,1,0,0,1},{2,1,0,1,0,2,0,0,1,1},
           {2,1,0,1,2,0,0,0,1,1},{3,0,0,1,2,0,0,0,1,1},{3,0,0,1,2,0,0,0,1,1},{3,0,0,3,0,0,0,0,1,1},{3,0,0,3,0,0,0,0,1,1} }
        };
    static Temporal expectedNextAfterStartOf[NUMBER_OF_HANDLES][NUMBER_OF_SEARCH_INTERVALS] = {
         {Temporal(1,2),Temporal(1,2),UNDEFINED_TEMPORAL, UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL},
         {Temporal(1,1),Temporal(1,1),Temporal(2,3),Temporal(2,3),UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL}
        };
    static Temporal expectedNextAfterEndOf[NUMBER_OF_HANDLES][NUMBER_OF_SEARCH_INTERVALS] = {
         {Temporal(1,2),UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL, UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL},
         {Temporal(1,1),Temporal(2,3),Temporal(2,3),UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL}
        };
    static Temporal expectedPreviousBeforeStartOf[NUMBER_OF_HANDLES][NUMBER_OF_SEARCH_INTERVALS] = {
         {UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,Temporal(0,2),Temporal(0,2),Temporal(1,2),Temporal(1,2),Temporal(1,2),Temporal(1,2),Temporal(1,2),Temporal(1,2)},
         {UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,Temporal(1,3),Temporal(1,3),Temporal(2,3),Temporal(2,3),Temporal(2,3),Temporal(2,3)}
        };
    static Temporal expectedPreviousBeforeEndOf[NUMBER_OF_HANDLES][NUMBER_OF_SEARCH_INTERVALS] = {
         {UNDEFINED_TEMPORAL,Temporal(0,2),Temporal(0,2),Temporal(1,2),Temporal(1,2),Temporal(1,2),Temporal(1,2),Temporal(1,2),Temporal(1,2),Temporal(1,2)},
         {UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,UNDEFINED_TEMPORAL,Temporal(1,3),Temporal(1,3),Temporal(2,3),Temporal(2,3),Temporal(2,3),Temporal(2,3),Temporal(2,3)}
        };
//========================================================================================= //

#define N_TIMES 10

class TemporalTableUTest :  public CxxTest::TestSuite{
private:

    Temporal* times[N_TIMES];
    Handle handles[N_TIMES];

    TemporalTable *temporalTable;
       
public:

    TemporalTableUTest(){
        for (int i = 0; i < N_TIMES; i++){
            times[i] = new Temporal(i*2,i*2);
            char name[1<<16];
            sprintf(name, "name-%d", i);
            Node *n = new Node(WORD_NODE, name);
            handles[i] = TLB::addAtom(n);
        }
    }

    ~TemporalTableUTest(){
        for (int i = 0; i < N_TIMES; i++){
            delete times[i];
            delete TLB::removeAtom(TLB::getAtom(handles[i]));
        }
    }

    void setUp(){
        temporalTable = new TemporalTable();
    }

    void tearDown(){
        delete(temporalTable);
    }

    void testAdd(){
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
            TS_ASSERT(!temporalTable->get(UNDEFINED_HANDLE, *(times[i])));
        }
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->add(handles[i], *(times[i]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            TS_ASSERT(result);
            delete result;
            result = temporalTable->get(UNDEFINED_HANDLE, *(times[i]));
            TS_ASSERT(result);
            delete result;
        }
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->add(handles[i], *(times[N_TIMES-1-i]));
        }
        for (int i = 0; i < N_TIMES; i++){
            bool firstHalf = i < N_TIMES/2;
            // Check times by handle
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[firstHalf?i:(N_TIMES-i-1)]) == 0);
            TS_ASSERT(hte->next);
            hte = hte->next;
            TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[firstHalf?(N_TIMES-i-1):i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Check handles by time
            result = temporalTable->get(UNDEFINED_HANDLE, *(times[i]));
            hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0 || CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[N_TIMES-i-1]) == 0);
            TS_ASSERT(hte->next);
            hte = hte->next;
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0 || CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[N_TIMES-i-1]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
        }
    }

    void testGetByHandle(){
        //HandleTemporalPairEntry* get(Handle);
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        for (int i = 0; i < N_TIMES; i++){
            if (i < N_TIMES/2) {
                // Insertions in ascendent order
                for (int j = 0; j < N_TIMES; j++){
                    temporalTable->add(handles[i], *(times[j]));
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
                    HandleTemporalPairEntry* hte = result;
                    for (int k = 0; k <= j; k++) {
                        TS_ASSERT(hte);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[k]) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            } else {
                // Insertions in descendent order
                for (int j = N_TIMES-1; j >=0 ; j--){
                    temporalTable->add(handles[i], *(times[j]));
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
                    HandleTemporalPairEntry* hte = result;
                    for (int k = j; k < N_TIMES; k++) {
                        TS_ASSERT(hte);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[k]) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            }
        }
    }

    void testGetByHandleAndTemporal() {
        //HandleTemporalPairEntry* get(Handle, Temporal*, bool)
        Temporal time (0,(N_TIMES-1)*2);
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
            temporalTable->add(handles[i], time);
        }
        for (int i = 0; i < N_TIMES; i++){
            if (i < N_TIMES/2) {
                // Insertions in ascendent order
                for (int j = 0; j < N_TIMES; j++){
                    temporalTable->add(handles[i], *(times[j]));
                    // Check times[0]
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i], *(times[0]));
                    HandleTemporalPairEntry* hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[0]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[0]), TemporalTable::OVERLAP);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), 
                              (TemporalEntry::compare(&time, times[0]) < 0)?&time:times[0]) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), 
                              (TemporalEntry::compare(&time, times[0]) > 0)?&time:times[0]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check times[j]
                    result = temporalTable->get(handles[i], *(times[j]));
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[j]), TemporalTable::OVERLAP);
                    hte = result;
//                    printf("hte = %s\n", hte->toString().c_str());
//                    printf("expected time = %s\n", ((TemporalEntry::compare(&time, times[j]) < 0)?&time:times[j])->toString().c_str());
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), 
                              (TemporalEntry::compare(&time, times[j]) < 0)?&time:times[j]) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), 
                              (TemporalEntry::compare(&time, times[j]) > 0)?&time:times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check with a time interval that contains all times
                    result = temporalTable->get(handles[i], time);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), &time) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], time, TemporalTable::OVERLAP);
                    hte = result;
                    for (int k = 0; k <= (j+1); k++) {
                        TS_ASSERT(hte);
                        Temporal* expectedTime = (k==0)?times[0]:((k>1)?times[k-1]:&time);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), expectedTime) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            } else {
                // Insertions in descendent order
                for (int j = N_TIMES-1; j >=0 ; j--){
                    temporalTable->add(handles[i], *(times[j]));
                    // Check times[N_TIMES-1]
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i], *(times[N_TIMES-1]));
                    HandleTemporalPairEntry* hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[N_TIMES-1]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[N_TIMES-1]), TemporalTable::OVERLAP);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), &time) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[N_TIMES-1]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check times[j]
                    result = temporalTable->get(handles[i], *(times[j]));
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[j]), TemporalTable::OVERLAP);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), (j==0)?times[j]:&time) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), (j==0)?&time:times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check with a time interval that contains all times
                    result = temporalTable->get(handles[i], time);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), &time) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], time, TemporalTable::OVERLAP);
                    hte = result;
                    for (int k = j; k <= N_TIMES; k++) {
                        TS_ASSERT(hte);
                        Temporal* expectedTime = (j==0)?(k==0?times[0]:k==1?&time:times[k-1])
                                                       :(k==j?&time:times[k-1]);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), expectedTime) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            }
        }
        
    }

    void testGetByHandleAndTemporalWithOtherCriteria() {
        for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
            temporalTable->add(handles[i], Temporal(i,i));      // [0,0]    [1,1]
            temporalTable->add(handles[i], Temporal(i+1,i+2));  // [1,2]    [2,3]
            temporalTable->add(handles[i], Temporal(i,i+2));    // [0,2]    [1,3]
        }
        for (int h = 0; h < NUMBER_OF_HANDLES; h++) {
            for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
                for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {
                    HandleTemporalPairEntry* result = temporalTable->get(handles[h],search_intervals[t],criteria[c]);
                    HandleTemporalPairEntry* hte = result;
                    int numberOfReturnedEntries = hte->getSize();
                    if(numberOfReturnedEntries != expectedNumberOfEntries[h][t][c]) {
                        printf("\nWrong number of entries returned for h=%s, t=%s, c=%s\nExpected %d, but got %d => %s", 
                               TLB::getAtom(handles[h])->toString().c_str(), 
                               search_intervals[t].toString().c_str(), 
                               TemporalTable::getTemporalRelationshipStr(criteria[c]), 
                               expectedNumberOfEntries[h][t][c], numberOfReturnedEntries, hte->toString().c_str());
                    } 
                    TS_ASSERT(numberOfReturnedEntries == expectedNumberOfEntries[h][t][c]); 
                    for (int i = 0; i < expectedNumberOfEntries[h][t][c]; i++) {
                        TS_ASSERT(hte);
                        if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterStartOf[h][t]) {
                                printf("Next after start of t %s for h (%s) does not match\nExpected %s, but got %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       expectedNextAfterStartOf[h][t].toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterEndOf[h][t]) {
                                printf("Next after end of t %s for h (%s) does not match\nExpected %s, but got %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       expectedNextAfterEndOf[h][t].toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterEndOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeStartOf[h][t]) {
                                printf("Previous before start of t %s for h (%s) does not match\nExpected %s, but got %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       expectedPreviousBeforeStartOf[h][t].toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeEndOf[h][t]) {
                                printf("Previous before end of t %s for h (%s) does not match\nExpected %s, but got %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       expectedPreviousBeforeEndOf[h][t].toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeEndOf[h][t]);
                        }
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            } 
        }
    }

    void testGetByTemporal(){
        //HandleTemporalPairEntry* get(Temporal*, bool = true);
        
        // Check if there is no entry yet
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        
        // Check association of all times to the first handle
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->add(handles[0], *(times[i]));
        }
        // Exact match
        for (int i = 0; i < N_TIMES; i++){
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(times[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
            TS_ASSERT(!(hte->next));
            delete result;
        }
        // Overlap match
        for (int i = 0; i < N_TIMES; i++){
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(times[i]), TemporalTable::OVERLAP);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
            TS_ASSERT(!(hte->next));
            delete result;
        }
        
        // Check association of the first time to all handles
        for (int i = 1; i < N_TIMES; i++){
            temporalTable->add(handles[i], *(times[0]));
        }
        // Exact match
        HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(times[0]));
        HandleTemporalPairEntry* hte = result;
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(hte);
            // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
            // TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            hte = hte->next;
        }
        TS_ASSERT(!hte);
        delete result;
        // Overlap match
        result = temporalTable->get(UNDEFINED_HANDLE, *(times[0]), TemporalTable::OVERLAP);
        hte = result;
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(hte);
            // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
            // TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            hte = hte->next;
        }
        TS_ASSERT(!hte);
        delete result;
    }

    // Special case 1: check different intervals contained by an existent interval
    void testGetByTemporalSpecialCase1(){
        Temporal time(0,20);
        // Check if TemporalTable is empty
        TS_ASSERT(!temporalTable->get(UNDEFINED_HANDLE, time));
        TS_ASSERT(!temporalTable->get(UNDEFINED_HANDLE, time, TemporalTable::OVERLAP));
        // Inserts new time
        temporalTable->add(handles[0],time);
        // Gets time with exact match
        HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, time);
        HandleTemporalPairEntry* hte = result;
        TS_ASSERT(hte);
        TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
        TS_ASSERT(!(hte->next));
        delete result;
        // Gets time with Overlap match
        result = temporalTable->get(UNDEFINED_HANDLE, time, TemporalTable::OVERLAP);
        hte = result;
        TS_ASSERT(hte);
        TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
        TS_ASSERT(!(hte->next));
        delete result;
        // Lookups using several different times whose interval is contained by the interval of the inserted time
        for (int i = 0; i < N_TIMES; i++){
            // Exact match does not return anything
            TS_ASSERT(!temporalTable->get(UNDEFINED_HANDLE, *(times[i])));
            // Overlap match return one entry for all times
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(times[i]), TemporalTable::OVERLAP);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
            TS_ASSERT(!(hte->next));
            delete result;
        }
    }

    // Special case 2: check an interval that is contained by several existing intervals 
    void testGetByTemporalSpecialCase2(){
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES/2; i++){
            specialTimes[i] = new Temporal(i*2,(N_TIMES-i)*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        Temporal time(N_TIMES, N_TIMES);
        // Exact match
        TS_ASSERT(!temporalTable->get(UNDEFINED_HANDLE, time));
        // Overlap match
        HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, time, TemporalTable::OVERLAP);
        HandleTemporalPairEntry* hte = result;
        for (int i = 0; i < N_TIMES/2; i++){
            TS_ASSERT(hte);
            // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
            // TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            hte = hte->next;
        }
        TS_ASSERT(!hte);
        delete result;
        for (int i = 0; i < N_TIMES/2; i++){
            delete specialTimes[i];
        }
    }
        
    // Special case 3: check intervals that has the same lower bound of several existing intervals
    void testGetByTemporalSpecialCase3(){
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES/2; i++){
            specialTimes[i] = new Temporal(0,i*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES/2; i++){
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]), TemporalTable::OVERLAP);
            hte = result;
            for (int j = 0; j < N_TIMES/2; j++){
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES/2; i++){
            delete specialTimes[i];
        }
    }
        
    // Special case 4: check intervals that has the same upper bound of several existing intervals
    void testGetByTemporalSpecialCase4(){
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES/2; i++){
            specialTimes[i] = new Temporal(i*2,N_TIMES);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES/2; i++){
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]), TemporalTable::OVERLAP);
            hte = result;
            for (int j = 0; j < N_TIMES/2; j++){
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES/2; i++){
            delete specialTimes[i];
        }
    }

    // Special case 5: check intervals against several existing intervals that has many points of intersection with other intervals
    void testGetByTemporalSpecialCase5(){
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES/2; i++){
            specialTimes[i] = new Temporal(i*2,(i+(N_TIMES/2)-2)*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES/2; i++){
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]), TemporalTable::OVERLAP);
            hte = result;
            int howManyIntersections = (i > 0 && i < (N_TIMES/2-1))?(N_TIMES/2):(N_TIMES/2-1);
            for (int j = 0; j < howManyIntersections; j++){
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES/2; i++){
            delete specialTimes[i];
        }
    }
        
    // Special case 6: check intervals against several existing intervals that has only one point of intersection with other intervals
    void testGetByTemporalSpecialCase6(){
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES/2; i++){
            specialTimes[i] = new Temporal(i*2,(i+1)*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES/2; i++){
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]), TemporalTable::OVERLAP);
            hte = result;
            int howManyIntersections = (i > 0 && i < (N_TIMES/2-1))?3:2;
            for (int j = 0; j < howManyIntersections; j++){
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES/2; i++){
            delete specialTimes[i];
        }
    }
        
    // Special case 7: check intervals against several existing intervals that has no point of intersection with another intervals
    void testGetByTemporalSpecialCase7(){
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES/2; i++){
            specialTimes[i] = new Temporal(i*2,i*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES/2; i++){
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            // Exact match
            result = temporalTable->get(UNDEFINED_HANDLE, *(specialTimes[i]), TemporalTable::OVERLAP);
            hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(CoreUtils::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
        }
        for (int i = 0; i < N_TIMES/2; i++){
            delete specialTimes[i];
        }
    }

    void testGetByTemporalWithOtherCriteria() {
        for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
            temporalTable->add(handles[i], Temporal(i,i));      // [0,0]    [1,1]
            temporalTable->add(handles[i], Temporal(i+1,i+2));  // [1,2]    [2,3]
            temporalTable->add(handles[i], Temporal(i,i+2));    // [0,2]    [1,3]
        }

        for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
            for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {
                HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE,search_intervals[t],criteria[c]);
                HandleTemporalPairEntry* hte = result;
                int numberOfReturnedEntries = hte->getSize();
                int totalExpectedNumberOfEntries = 
                    (criteria[c] != TemporalTable::NEXT_AFTER_START_OF &&
                     criteria[c] != TemporalTable::NEXT_AFTER_END_OF && 
                     criteria[c] != TemporalTable::PREVIOUS_BEFORE_START_OF &&
                     criteria[c] != TemporalTable::PREVIOUS_BEFORE_END_OF)?
                        (expectedNumberOfEntries[0][t][c] + expectedNumberOfEntries[1][t][c]):
                        (expectedNumberOfEntries[0][t][c] | expectedNumberOfEntries[1][t][c]);
                if(numberOfReturnedEntries != totalExpectedNumberOfEntries) {
                    printf("\nWrong number of entries returned t=%s, c=%s\nExpected %d, but got %d => %s", 
                           search_intervals[t].toString().c_str(), 
                           TemporalTable::getTemporalRelationshipStr(criteria[c]), 
                           totalExpectedNumberOfEntries, numberOfReturnedEntries, hte->toString().c_str());
                } 
                TS_ASSERT(numberOfReturnedEntries == totalExpectedNumberOfEntries); 
                for (int i = 0; i < totalExpectedNumberOfEntries; i++) {
                    TS_ASSERT(hte);
                    if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) { 
                        const Temporal& nextAfterStartOf = 
                            (expectedNextAfterStartOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterStartOf[1][t]:
                            (expectedNextAfterStartOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterStartOf[0][t]: 
                            (expectedNextAfterStartOf[0][t] < expectedNextAfterStartOf[1][t])?
                             expectedNextAfterStartOf[0][t]:
                             expectedNextAfterStartOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) != nextAfterStartOf) {
                            printf("Next after start of t %s does not match\nExpected %s, but got %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   nextAfterStartOf.toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == nextAfterStartOf);
                    } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) { 
                        const Temporal& nextAfterEndOf = 
                            (expectedNextAfterEndOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterEndOf[1][t]:
                            (expectedNextAfterEndOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterEndOf[0][t]: 
                            (expectedNextAfterEndOf[0][t] < expectedNextAfterEndOf[1][t])?
                             expectedNextAfterEndOf[0][t]:
                             expectedNextAfterEndOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) != nextAfterEndOf) {
                            printf("Next after end of t %s does not match\nExpected %s, but got %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   nextAfterEndOf.toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == nextAfterEndOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) { 
                        const Temporal& previousBeforeStartOf = 
                            (expectedPreviousBeforeStartOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeStartOf[1][t]:
                            (expectedPreviousBeforeStartOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeStartOf[0][t]: 
                            (expectedPreviousBeforeStartOf[0][t] > expectedPreviousBeforeStartOf[1][t])?
                             expectedPreviousBeforeStartOf[0][t]:
                             expectedPreviousBeforeStartOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) != previousBeforeStartOf) {
                            printf("Previous before start of t %s does not match\nExpected %s, but got %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   previousBeforeStartOf.toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == previousBeforeStartOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) { 
                        const Temporal& previousBeforeEndOf = 
                            (expectedPreviousBeforeEndOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeEndOf[1][t]:
                            (expectedPreviousBeforeEndOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeEndOf[0][t]: 
                            (expectedPreviousBeforeEndOf[0][t] > expectedPreviousBeforeEndOf[1][t])?
                             expectedPreviousBeforeEndOf[0][t]:
                             expectedPreviousBeforeEndOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) != previousBeforeEndOf) {
                            printf("Previous before end of t %s does not match\nExpected %s, but got %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   previousBeforeEndOf.toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == previousBeforeEndOf);
                    }
                    hte = hte->next;
                }
                TS_ASSERT(!hte);
                delete result;
            }
        } 
    }

    void testRemoveByHandle(){
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Add entries
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->add(handles[i], *(times[i]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes and check if ok
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->remove(handles[i]);
            for (int j = 0; j < N_TIMES; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
        // Adds entries again
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->add(handles[i], *(times[i]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes in the inverse order and check if ok
        for (int i = N_TIMES-1; i >= 0; i--){
            temporalTable->remove(handles[i]);
            for (int j = 0; j < N_TIMES; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j >= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
        // Now adds two entries for each handle
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[(i+1)%N_TIMES]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes and check if ok
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->remove(handles[i]);
            for (int j = 0; j < N_TIMES; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
    }

    void testRemoveByHandleAndTemporalExact(){
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES-1; i++){
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes only one of the insertions of each handle and check
        for (int i = 0; i < N_TIMES-1; i++){
            if (i < N_TIMES/2) {
                temporalTable->remove(handles[i], *(times[i]));
            } else {
                temporalTable->remove(handles[i], *(times[i+1]));
            }
            for (int j = 0; j < N_TIMES-1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Removes the remaining insertions of each handle and check
        for (int i = 0; i < N_TIMES-1; i++){
            if (i < N_TIMES/2) {
                temporalTable->remove(handles[i], *(times[i+1]));
            } else {
                temporalTable->remove(handles[i], *(times[i]));
            }
            for (int j = 0; j < N_TIMES-1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
    }    

    void testRemoveByHandleAndTemporalNonExact(){
        // FIRST TEST THE SAME CASES OF EXACT MATCH:
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES-1; i++){
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes only one of the insertions of each handle and check
        for (int i = 0; i < N_TIMES-1; i++){
            if (i < N_TIMES/2) {
                temporalTable->remove(handles[i], *(times[i]), TemporalTable::OVERLAP);
            } else {
                temporalTable->remove(handles[i], *(times[i+1]), TemporalTable::OVERLAP);
            }
            for (int j = 0; j < N_TIMES-1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Removes the remaining insertions of each handle and check
        for (int i = 0; i < N_TIMES-1; i++){
            if (i < N_TIMES/2) {
                temporalTable->remove(handles[i], *(times[i+1]), TemporalTable::OVERLAP);
            } else {
                temporalTable->remove(handles[i], *(times[i]), TemporalTable::OVERLAP);
            }
            for (int j = 0; j < N_TIMES-1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
        
        // TEST OTHER SPECIFIC CASES
        // Declares different times for using in this test
        Temporal* specialTimes[N_TIMES];
        for (int i = 0; i < N_TIMES; i++){
            specialTimes[i] = new Temporal(0,i*2);
        }
        // Adds three entries for each handle
        for (int i = 0; i < N_TIMES-1; i++){
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            temporalTable->add(handles[i], *(specialTimes[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        /*
        printf("All entries in TemporalTable = %s\n", temporalTable->get(UNDEFINED_HANDLE)->toString().c_str()); 
        Temporal specialTime(0, (N_TIMES-1)*2); // overlaps any inserted time
        printf("specialTime = %s\n", specialTime.toString().c_str()); 
        temporalTable->remove(UNDEFINED_HANDLE, specialTime, TemporalTable::OVERLAP);
        */
        // Removes the entries and check
        for (int i = 0; i < N_TIMES-1; i++){
            for (int j = 0; j < N_TIMES; j++) {
				// For each handle i => remove by times (0,j) => (0,1), (0,2), ..., (0,N)
                temporalTable->remove(handles[i], *(specialTimes[j]), TemporalTable::OVERLAP);
                HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
                HandleTemporalPairEntry* hte = result;
                if (j < i) {
                    // [0,j+1] removed, [j,j] and [j+1,j+1] kept
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else if (j == i) {
                    // [j,j] [0,j+1] removed, [j+1,j+1] kept
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    // [j,j] [j+1,j+1] [0,j+1] removed
                    TS_ASSERT(!hte);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(UNDEFINED_HANDLE);
        //printf("All entries in TemporalTable = %s\n", hte->toString().c_str()); 
        TS_ASSERT(!hte);
        for (int i = 0; i < N_TIMES; i++){
            delete specialTimes[i];
        }
    }    

    void testRemoveByTemporalExact(){
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES-1; i++){
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes each time and check
        for (int i = 0; i < N_TIMES; i++){
//printf("i = %d\n", i);
            temporalTable->remove(UNDEFINED_HANDLE, *(times[i]));
            for (int j = 0; j < N_TIMES-1; j++) {
//printf("j = %d\n", j);
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
//printf("hte => %s\n", hte->toString().c_str());
                if (j < i) {
                    TS_ASSERT(!hte);
                } else if (j == i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
    }    

    void testRemoveByTemporalNonExact(){
        // FIRST TEST THE SAME CASES OF EXACT MATCH:
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++){
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES-1; i++){
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes each time and check
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->remove(UNDEFINED_HANDLE, *(times[i]), TemporalTable::OVERLAP);
            for (int j = 0; j < N_TIMES-1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j < i) {
                    TS_ASSERT(!hte);
                } else if (j == i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
        
        // TEST OTHER SPECIFIC CASES
        // Declares different times for using in this test
        Temporal* specialTimes[N_TIMES];
        for (int i = 0; i < N_TIMES; i++){
            specialTimes[i] = new Temporal(0,i*2);
        }
        // Adds some entries for each handle
        for (int i = 0; i < N_TIMES-1; i++){
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            temporalTable->add(handles[i], *(specialTimes[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes the entries and check
        for (int i = 0; i < N_TIMES; i++){
            temporalTable->remove(UNDEFINED_HANDLE, *(specialTimes[i]), TemporalTable::OVERLAP);
            for (int j = 0; j < N_TIMES-1; j++){
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                //printf("j= %d, i = %d, hte = %s\n", j, i, hte->toString().c_str());
                if (j < i) {
                    // [j,j] [j+1,j+1] [0,j+1] removed
                    TS_ASSERT(!hte);      
                } else if (j == i) {
                    // [j,j] [0,j+1] removed, [j+1,j+1] kept
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    // [0,j+1] removed, [j,j] and [j+1,j+1] kept
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(UNDEFINED_HANDLE);
        TS_ASSERT(!hte);
        for (int i = 0; i < N_TIMES; i++){
            delete specialTimes[i];
        }
    }    

    void testRemoveByHandleAndTemporalWithOtherCriteria() {
        for (int h = 0; h < NUMBER_OF_HANDLES; h++) {
            for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
                for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {
                	// adds all the entries for each removal test
			        for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
            			TS_ASSERT(!temporalTable->get(handles[i]));
			            temporalTable->add(handles[i], Temporal(i,i));      // [0,0]    [1,1]
            			temporalTable->add(handles[i], Temporal(i+1,i+2));  // [1,2]    [2,3]
			            temporalTable->add(handles[i], Temporal(i,i+2));    // [0,2]    [1,3]
			        }
			        int totalNumberOfEntries = NUMBER_OF_HANDLES*3;
                    HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE);
                    HandleTemporalPairEntry* hte = result;
                    TS_ASSERT(totalNumberOfEntries == hte->getSize());
                    delete result;
			        
			        // Remove the entries
                    temporalTable->remove(handles[h],search_intervals[t],criteria[c]);

                    // Check if the entries were removed
                    result = temporalTable->get(UNDEFINED_HANDLE);
                    hte = result;
                    int numberOfReturnedEntries = hte->getSize();
                    if(numberOfReturnedEntries != (totalNumberOfEntries - expectedNumberOfEntries[h][t][c])) {
                        printf("\nWrong number of entries returned for h=%s, t=%s, c=%s\nExpected %d, but got %d => %s", 
                               TLB::getAtom(handles[h])->toString().c_str(), 
                               search_intervals[t].toString().c_str(), 
                               TemporalTable::getTemporalRelationshipStr(criteria[c]), 
                               expectedNumberOfEntries[h][t][c], numberOfReturnedEntries, hte->toString().c_str());
                    } 
                    TS_ASSERT(numberOfReturnedEntries == (totalNumberOfEntries - expectedNumberOfEntries[h][t][c])); 

                    
                    for (int i = 0; i < numberOfReturnedEntries; i++) {
                        TS_ASSERT(hte);
                        if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterStartOf[h][t]) {
                                printf("Next after start of t %s for h (%s), that should have been removed is still there: %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterEndOf[h][t]) {
                                printf("Next after end of t %s for h (%s), that should have been removed is still there: %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterEndOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeStartOf[h][t]) {
                                printf("Previous before start of t %s for h (%s), that should have been removed is still there: %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) { 
                            if(*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeEndOf[h][t]) {
                                printf("Previous before end of t %s for h (%s), that should have been removed is still there: %s\n", 
                                       search_intervals[t].toString().c_str(), 
                                       TLB::getAtom(handles[h])->toString().c_str(), 
                                       hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeEndOf[h][t]);
                        }
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                    
                    // reset the temporal table
                    delete temporalTable;
                    temporalTable = new TemporalTable();
                }
            } 
        }
    }

    void testRemoveByTemporalWithOtherCriteria() {
        for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
            for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {
              	
              	// adds all the entries for each removal test
		        for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
        		    TS_ASSERT(!temporalTable->get(handles[i]));
        	    	temporalTable->add(handles[i], Temporal(i,i));      // [0,0]    [1,1]
		            temporalTable->add(handles[i], Temporal(i+1,i+2));  // [1,2]    [2,3]
	    	        temporalTable->add(handles[i], Temporal(i,i+2));    // [0,2]    [1,3]
		        }
		        int totalNumberOfEntries = NUMBER_OF_HANDLES*3;
                HandleTemporalPairEntry* result = temporalTable->get(UNDEFINED_HANDLE);
                HandleTemporalPairEntry* hte = result;
                TS_ASSERT(totalNumberOfEntries == hte->getSize());
                delete result;
		        
		        // Remove the entries
                temporalTable->remove(UNDEFINED_HANDLE,search_intervals[t],criteria[c]);
                
                // Check if the entries were removed
                result = temporalTable->get(UNDEFINED_HANDLE);
                hte = result;
                int numberOfReturnedEntries = hte->getSize();
                int totalExpectedNumberOfEntries = totalNumberOfEntries -( 
                    (criteria[c] != TemporalTable::NEXT_AFTER_START_OF &&
                     criteria[c] != TemporalTable::NEXT_AFTER_END_OF &&
                     criteria[c] != TemporalTable::PREVIOUS_BEFORE_START_OF &&
                     criteria[c] != TemporalTable::PREVIOUS_BEFORE_END_OF)?
                        (expectedNumberOfEntries[0][t][c] + expectedNumberOfEntries[1][t][c]):
                        (expectedNumberOfEntries[0][t][c] | expectedNumberOfEntries[1][t][c])
                        );
                //printf("expectedNumberOfEntries[0][t][c] = %d, expectedNumberOfEntries[1][t][c] = %d\n", expectedNumberOfEntries[0][t][c], expectedNumberOfEntries[1][t][c]);
                //printf("nRetEntries = %d, totalExpEntries = %d\n", numberOfReturnedEntries, totalExpectedNumberOfEntries);
                if(numberOfReturnedEntries != totalExpectedNumberOfEntries) {
                    printf("\nWrong number of entries returned t=%s, c=%s\nExpected %d, but got %d => %s", 
                           search_intervals[t].toString().c_str(), 
                           TemporalTable::getTemporalRelationshipStr(criteria[c]), 
                           totalExpectedNumberOfEntries, numberOfReturnedEntries, hte->toString().c_str());
                } 
                TS_ASSERT(numberOfReturnedEntries == totalExpectedNumberOfEntries); 
                for (int i = 0; i < totalExpectedNumberOfEntries; i++) {
                    TS_ASSERT(hte);
                    if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) { 
                        const Temporal& nextAfterStartOf = 
                            (expectedNextAfterStartOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterStartOf[1][t]:
                            (expectedNextAfterStartOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterStartOf[0][t]: 
                            (expectedNextAfterStartOf[0][t] < expectedNextAfterStartOf[1][t])?
                             expectedNextAfterStartOf[0][t]:
                             expectedNextAfterStartOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) == nextAfterStartOf) {
                            printf("Next after start of t %s, that should have been removed, is still there: %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != nextAfterStartOf);
                    } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) { 
                        const Temporal& nextAfterEndOf = 
                            (expectedNextAfterEndOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterEndOf[1][t]:
                            (expectedNextAfterEndOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedNextAfterEndOf[0][t]: 
                            (expectedNextAfterEndOf[0][t] < expectedNextAfterEndOf[1][t])?
                             expectedNextAfterEndOf[0][t]:
                             expectedNextAfterEndOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) == nextAfterEndOf) {
                            printf("Next after end of t %s, that should have been removed, is still there: %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != nextAfterEndOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) { 
                        const Temporal& previousBeforeStartOf = 
                            (expectedPreviousBeforeStartOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeStartOf[1][t]:
                            (expectedPreviousBeforeStartOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeStartOf[0][t]: 
                            (expectedPreviousBeforeStartOf[0][t] > expectedPreviousBeforeStartOf[1][t])?
                             expectedPreviousBeforeStartOf[0][t]:
                             expectedPreviousBeforeStartOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) == previousBeforeStartOf) {
                            printf("Previous before start of t %s, that should have been removed, is still there: %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != previousBeforeStartOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) { 
                        const Temporal& previousBeforeEndOf = 
                            (expectedPreviousBeforeEndOf[0][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeEndOf[1][t]:
                            (expectedPreviousBeforeEndOf[1][t] == UNDEFINED_TEMPORAL)? 
                             expectedPreviousBeforeEndOf[0][t]: 
                            (expectedPreviousBeforeEndOf[0][t] > expectedPreviousBeforeEndOf[1][t])?
                             expectedPreviousBeforeEndOf[0][t]:
                             expectedPreviousBeforeEndOf[1][t];
                        if(*(hte->handleTemporalPair.getTemporal()) == previousBeforeEndOf) {
                            printf("Previous before end of t %s, that should have been removed, is still there: %s\n", 
                                   search_intervals[t].toString().c_str(), 
                                   hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != previousBeforeEndOf);
                    }
                    hte = hte->next;
                }
                TS_ASSERT(!hte);
                delete result;

                // reset the temporal table
                delete temporalTable;
                temporalTable = new TemporalTable();
            }
        } 
    }

    void testStress() {
        int NUMBER_OF_ENTRIES = 100;
        //printf("testStress(): adding...\n");
        for (int i = 0; i < N_TIMES; i++){
            for (int j = 0; j < N_TIMES; j++){
                temporalTable->add(handles[i], *(times[j]));
            }
        }
        for (int i = 0; i < N_TIMES; i++) {
            for (int j = N_TIMES; j < NUMBER_OF_ENTRIES; j++){
                temporalTable->add(handles[i], Temporal(N_TIMES-1,j));
            }
        }
        //printf("testStress(): removing...\n");
        for (int i = 0; i < N_TIMES; i++){
            for (int j = 0; j < N_TIMES; j++){
                temporalTable->remove(handles[i], *(times[j]));
            }
        }
        for (int i = 0; i < N_TIMES; i++) {
            for (int j = N_TIMES; j < NUMBER_OF_ENTRIES; j++){
                temporalTable->remove(handles[i], Temporal(N_TIMES-1, j));
            }
        }
    }
    
    void testSpecificRemoveCase1() {
        TemporalTable table;
        Temporal t1(100);
        Temporal t2(200);
        table.add((Handle) 1, t1); 
        table.add((Handle) 1, t2);
        TS_ASSERT(table.remove((Handle) 1, Temporal(150), TemporalTable::STARTS_BEFORE));
        HandleTemporalPairEntry* result = table.get((Handle) 1);
        HandleTemporalPairEntry* htpe = result;
        TS_ASSERT(htpe);
        TS_ASSERT(htpe->handleTemporalPair.getHandle() == (Handle) 1); 
        TS_ASSERT(*(htpe->handleTemporalPair.getTemporal()) == t2); 
        TS_ASSERT(table.remove((Handle) 1));
        htpe = table.get((Handle) 1);
        TS_ASSERT(!htpe);
        delete result;
    }
    
};
